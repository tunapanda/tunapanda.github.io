{"name":"Swag Tech Overview","tagline":"Tunapanda project documentation","body":"## Introduction\r\n \r\nSwag is a system for guiding learners through different learning paths. It does not dictate a \r\nspecific path to the learner, but suggests that some knowledge are prerequisites to other \r\nknowledge. It engages the user by relying on metaphors from computer games, and tries to \r\ntrigger the users curiosity for exploration and desire for completeness.  \r\n \r\n## Concepts\r\nThere are some concepts that work together to make up the complete system. These are described in more detail on the following pages. \r\n \r\n### ● Swagmap \r\nA map of interconnected nodes that guides the user through the learning experience. \r\n  \r\n### ● Swagifact \r\nAn atom of learning. Each node in the swagmap is a swagifact. \r\n \r\n### ● Learning Record Store \r\nThe database that keeps track of which swagifacts each user has completed. \r\n \r\n### ● Reporting Applications \r\nAn application that sits in the background and gather information about what the user does and reports this to the Learning Record Store. \r\n![arch](https://github.com/tunapanda/tunapanda.github.io/blob/master/images/swagmap.png?raw=true)\r\n\r\n## Swagmaps\r\n![swag](https://github.com/tunapanda/tunapanda.github.io/blob/master/images/swag.png?raw=true)\r\nA Swagmap is a map of interconnected nodes. Each node represents a swagifact, and a node can be shown as complete or not yet completed. Depending on how the swagmap is defined, certain swagifacts can be set as prerequisites for other swagifacts, so the depending swagifacts are not shown unless the prerequisites are completed. \r\n \r\nClicking on a swagifact in the swagmap will open up information showing what the user needs to do for that swagifact to be \r\ncompleted. If the swagifact can be completed online, the user will be taken directly to where the swagifact can be completed. \r\n \r\nThe swagmap software is a web based software and is currently in an early stage of development. It currently looks like in the top right figure. Here, the circles represents the swagifacts, and the one marked in red is represented as \r\ncompleted. This is a technical prototype to test the functionality, the goal is that this should be a compelling, game like interface with game like interaction metaphors and animations. The following images can be seen as a mood board to serve as inspiration for what we want the application to look like eventually.  \r\n \r\n![final](https://github.com/tunapanda/tunapanda.github.io/blob/master/images/final.png?raw=true)\r\n\r\n\r\n## Swagifacts\r\n \r\nA swagifact represents an atom of learning. A swagifact can represent something that the user can experience online, such as watching a video or answering some multiple choice questions, or it can represent something the user needs to do in an outside system, in which case it will be reported by reporting application.  \r\n \r\nThe swag system does very little in terms of defining how a swagifact should actually be implemented. All it knows is that a swagifact resides on a url, and upon clicking on the swagifact the user will be taken to that url.  \r\n \r\nIt is assumed that when the user completes the swagifact, this will be reported to the LRS using xAPI, but how this is actually implemented is up to the particular swagifact or reporting application. \r\n \r\nWe have started creating swagifacts in H5P , an open source tool for creating e­learning artifacts in HTML5. \r\n\r\n## Learning Record Store\r\n\r\n![L_Locker](https://github.com/tunapanda/tunapanda.github.io/blob/master/images/graph.png?raw=true)\r\n\r\nThe learning record store keeps track of the progress for each user. In order to talk to the LRS we use the xAPI  protocol. The LRS is a standardized component that speaks xAPI, i.e. not something we have built specifically for the Swag system, and we can replace the currently used LRS with another one as long as that one speak xAPI. We currently use Learning Locker, which is an open source implementation of an xAPI compliant LRS. \r\n \r\nxAPI is a RESTful API, which means that it uses HTTP as its underlying protocol. This is the same protocol that a web browser uses to talk to a webserver. This means that it is relatively simple to create software that speaks it, since it is possible to reuse software libraries already created for other HTTP communication. There are implementations of xAPI in \r\nmost popular programming languages. \r\n\r\n\r\n## Reporting Applications\r\n![reporter](https://github.com/tunapanda/tunapanda.github.io/blob/master/images/terminal.png?raw=true)\r\n\r\nWhen we create swagifacts, we can make it easy for ourselves and choose tools that support xAPI, and these will easily integrate with the rest of the architecture. H5P is an example of such a tool. However, we would like to be able to gather information from as many sources as possible, also from sources that do not support xAPI. In these cases, we use a reporting application to bridge the gap from those systems to our LRS.  \r\n \r\nOne example of such a reporter application is ktouchxapi, which takes statistics from the touch typing tutor application KTouch  and inserts it into our xAPI compliant LRS. \r\n \r\nIn order to have a modular approach to the architecture of the system, the reporting application doesn’t have dependencies on any other components of the system,  other than the fact that it speaks xAPI. Reporting applications are command line tools that can be run periodically in the background, and they look and behave in similar ways to standard UNIX command line tools. \r\n \r\nKtouchxapi is the first reporting application we have developed, we envision more of these in \r\nthe future. The next envisioned reporting application is for arbtt , which is a system that tracks \r\n5\r\nwhich applications a user runs and how often and how long these applications are used. This \r\nway, we can give users swag credits upon using certain applications.","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}